def getNei(node,graph):
    moves=[(0,0,1),(0,0,-1),(0,1,0),(0,-1,0),(1,0,0),(-1,0,0)]
    valid=[]


    for move in moves:
        n=(node[0]+move[0],node[1]+move[1],node[2]+move[2])
        if (0<=n[0]<3 and 0<=n[1]<3 and 0<=n[2]<3 and graph[n[0]][n[1]][n[2]]==0):
            valid.append(n)
    return valid

def heuristic(node,goal):
    distance=abs(node[0]-goal[0])+abs(node[1]-goal[1])+abs(node[2]-goal[2])
    return distance

def hillclimbing(graph,start,goal):
    currentNode=start
    path=[start]
    while True:
        if currentNode==goal:
            return path,True
        nei = getNei(currentNode,graph)
        cur_min = float('inf')
        cur_best = None
        for neighbor in nei:
            temp= heuristic(neighbor,goal)
            if temp<cur_min:
                cur_min=temp
                cur_best=neighbor


        if cur_min<=heuristic(currentNode,goal):
            currentNode=cur_best
            path.append(cur_best)

        else:
            break
    return path,True


start=(0,0,0)
goal=(3,3,3)

graph = [
    [[0,0,0,0],
     [0,1,1,1],
     [0,0,0,0],
     [0,1,0,0],],

    [[0,0,1,0],
     [0,0,1,1],
     [0,0,0,0],
     [0,1,1,1],],

    [[1,0,1,0],
     [0,1,1,1],
     [0,0,1,0],
     [1,1,0,0],],

    [[0,0,1,0],
     [0,1,1,0],
     [0,0,1,0],
     [0,0,1,0],],

]

p,a=hillclimbing(graph,start,goal)

print(f'path:{p}')
print(a)

